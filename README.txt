Ονοματεπωνυμο: Ορφανιδης Ελευθεριος 
Α.Μ.: 1115201400133

Compilation: make
Run: ./werhauz -o operations file -h1 hashtable1 size -h2 hash2 size -s bucketsize

Για να ληξει το προγραμμα γραψτε την εντολη exit

Το flag -ο ειναι προαιρετικο , σε περιπτωση που δεν δοθει απο την γραμμη εντολων τοτε αυτοματα το προγραμμα δεχεται εντολες απο το stdin.

Στην εργασια εχουν υλοποιηθει ολα τα ερωτηματα εκτος απο το indist.Την εχω τρεξει και με valgrind οπου ετρεχε χωρις errors και χωρις leaks.
Η μορφη της δομης ειναι :
- Το hashtable ειναι υλοποιημενο ως struct το οποιο εκτος απο το ιδιο το table περιεχει τον αριθμο των κουβαδων, τον αριθμο των entries που εχει η δομη καθως και την χωριτηκοτητα των buckets.
- Καθε θεση του hashtable "δειχνει" σε ενα struct listnode (λιστα) το οποιο περιεχει:
	->Τον αριθμο κομβων που εχει ο πινακας listdata
	->Δεικτη στον επομενο κομβο της λιστας
	->Ενα πινακα που περιεχει δεικτες σε struct set τα οποια περιεχουν εναν αριθμο τηλεφωνου (ειτε originator ειτε destination αναλογα στο ποιο hashtable ειμαστε) και εναν δεικτη σε struct Records η οποια ειναι επισης λιστα που καθε κομβος της δειχνει σε ενα struct CDR.
- Το heap εχει υλοποιηθει με την μορφη 2-δικου δεντρου. Κραταμε στην ριζα τον αριθμο των κομβων και αναλογα με το ποιος αριθμος κομβου θα ειναι η επομενη εισαγωγη το εισαγουμε στην σωστη θεση και μετα κανουμε heapify. Συγκεκριμενα για την εισαγωγη αν ο κομβος που θα εισαγουμε ειναι ο 5ος , μετατρεπω το 5 σε δυαδικο αριθμο: 101 . Αγνοω το most significant bit και μετα μενω με το 01 . Αρα η εισαγωγη του κομβου θα γινει στο root->left->right . Γενικα για καθε 0 παμε στο αριστερο υποδενδρο και για καθε 1 παμε στο δεξια υποδενδρο.

Ουσιαστικα δεν υπαρχει κανενα διπλοτυπο στην δομη της εργασιας καθως οταν διαβαζεται μια εντολη insert γινεται malloc ενα struct CDR και κατα την εισαγωγη του στα hashtables δεν δημιουργειται καποιο αντιγραφο. Εχουμε δηλαδη 2 hashtables που "δειχνουν" στα ιδια struct CDR , το πρωτο απο την πλευρα του caller και το δευτερο απο την πλευρα του callee. Εχω πραγματοποιησει δηλαδη την bonus υλοποιηση.

Στην αρχη της εκτελεσης του προγραμματος καλειται η Hashinit για τα 2 hashtables η οποια απλα κανει malloc(h1 * sizeof(struct listnode*)) και αρχικοποιει τους δεικτες του πινακα σε NULL ( το ιδιο και με h2 για το δευτερο table) . Μετα κατα την εισαγωγη , αν η hashfunction επιστρεψει position το οποιο ειναι NULL (πρωτη εισαγωγη σε αυτο το position) τοτε αρχικοποιω την λιστα (struct listnode), εισαγω τον αριθμο τηλεφωνου και στην συνεχεια αρχικοποιω την λιστα (struct Records).

Στην περιπτωση της delete callerid το προγραμμα αναζητα στο hashtable1 το position στο οποιο βρισκεται ο αριθμος τηλεφωνου και στην συνεχεια με σειριακη αναζητηση ψαχνει στην λιστα του κουβα και μολις βρει το συγκεκριμενο αριθμο , με ομοιο τροπο ψαχνει το cdr_uniq_id στην λιστα (struct Records). Μολις το βρει, δεν διαγραφει το ιδιο το struct CDR αλλα σβηνει ουσιαστικα τον δεικτη σε αυτο , απο το Hashtable1 . Μετα ελεγχει αν η λιστα στην οποια βρισκοταν το cdr_uniq_id ειναι αδεια , αν ειναι αδεια την διαγραφει και με τον ιδιο τροπο ελεγχει αν η λιστα (struct listnode) στην οποια βρισκοταν ο αριθμος τηλεφωνου ειναι αδεια. Αν ειναι την διαγραφει και αυτη και θετει την θεση στο hashtable1 σε NULL, μιας και δεν εχει δεδομενα μεσα.

Στην περιπτωση της topdest χρησιμοποιω μια λιστα της οποιας καθε κομβος περιεχει εναν κωδικο χωρας και εναν αριθμο επαναληψεων. Οταν δωθει καποιο caller id γινεται αναζητηση στο hashtable1 και μολις βρεθει η λιστα (struct Records) του αριθμου αυτου , διατρεχει γραμμικα ολα τα CDR του. Για καθε CDR που βρισκει ελεγχει την λιστα που φτιαξαμε ειδικα για αυτη την ερωτηση, αν βρει καποιο κομβο της λιστας που περιεχει τον ιδιο κωδικο χωρας τοτε απλα προσθετει ενα στον μετρητη αυτου του κομβου , αλλιως δημιουργει στο τελος της λιστας ενα κομβο με αυτον τον κωδικο χωρας και αρχικοποιει τον μετρητη σε 1.Στο τελος τυπωνει τον κωδικο χωρας με τις περισσοτερες κλησεις καθως και τον αριθμο αυτων των κλησεων.

Οι εντολες lookup και find υλοποιουνται με τις ιδιες ακριβως συναρτησεις , απλα με διαφορετικα hashtables καθε φορα ( Το callee hashtable στην περιπτωση του lookup και του caller στην περιπτωση του find ). Με ιδιο τροπο με την topdest γινεται αναζητηση για να βρεθουμε στην λιστα που περιεχει τα CDRs του αριθμου αυτου (caller ή callee ). Μετα διατρεχουμε την λιστα και για καθε CDR που βρισκουμε ελεγχουμε με την χρηση της strptime , mktime και difftime τα στοιχεια του CDR και αν πληρουν τις προυποθεσεις τοτε το τυπωνουμε. Σε περιπτωση που δεν δωθει date ή time τοτε απλα τυπωνουμε ολη την λιστα που περιεχει τα CDR του αριθμου.

Η εντολη bye απλα επαναφερει το προγραμμα στην αρχικη του κατασταση. Διαγραφει τα hashtables και το heap και στην συνεχεια κανει HashInit στα 2 hashtables.

H εντολη print hashtable1 ή 2 , καλει απλα την PrintHash αναλογα με το ποιο hash table εχει δωθει ως ορισμα.

Η εντολη exit τερματιζει το προγραμμα και αποδεσμευει ολο τον χωρο που εχει δεσμευσει.
